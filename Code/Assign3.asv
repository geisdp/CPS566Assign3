clear all
close all
clc

testFolder = '.\check';
resultFolder = '..\Result';
images = dir(fullfile(testFolder, '*.jpg'));
template_width = 100;
scale_factors = {[2.5, 3.0, 3.5];
                 [1.0, 1.5, 2.0];
                 [2.0, 2.5, 3.0, 3.5];
                 [1.0, 1.5, 2.0];
                 [2.5, 3.0]
                };
canny_params = {[.1 .4, 1];
                [.1 .3, 1];
                [.1 .5, 1.5];
                [.2 .4, 1];
                [.3 .5, 1.5]
               };

% First, process all the signs in the sign template image
img_template = imread('templates.png');
img_template_gray = rgb2gray(img_template);
figure, imshow(img_template_gray), title('BW Original Templates');

[h, w] = size(img_template_gray);
num_templates = int16(w / template_width);
for i=1:num_templates
    new_img = zeros(h, template_width);
    new_img(1:h, 1:template_width) = img_template_gray(1:h, template_width*(i-1)+1:template_width*i);
    temp_edge = edge(new_img, "Canny", 0.1);
    temp_edge = cropImage(temp_edge);
    templates{i} = temp_edge;
    figure; imshow(temp_edge); title('Template ' + string(i));
end

for i=1:length(images)
    fileName = images(i).name;
    fprintf('Processing file %s...\n', fileName);
    filePath = fullfile(testFolder, fileName);
    img = imread(filePath);
    figure; imshow(img); title('Original Image');

    %% Step 1: Compute the Distance Transform
    img_gray = rgb2gray(img);

    params = canny_params{i};
    img_edge = edge(img_gray, "Canny", [params(1) params(2)], params(3));
    figure; imshow(img_edge); title('Canny Edge Detection');

    % Calculate the chamfer distance array
    img_chamfer = chamferDist(img_edge);
    figure; imshow(img_chamfer, []); title('Custom chamfer calculations');

    %% Step 2: Apply Chamfer Distance Matching
    matches = chamferMatch(img_chamfer, templates, scale_factors{i});
    
    %% Step 3: Color Verification
    
    % color class for each template index:
    % 1 = red sign (stop, yoeld)
    % 2 = white/blck (speed limit, one way)
    % 3 = yellow sign 

    templateColorClass = [1 2 3 3 2 1];
    
    [img_h, img_w] = size(img_gray);

    verified_matches = {};
    v_idx = 1;

    for k=1:numel(matches)
        info = matches{k}; % [templateIdx, scale, row, col, score]
        t_idx = info(1);
        scale = info(2);
        r1 = round(info(3));
        c1 = round(info(4));
        score = info(5);
        color_class = templateColorClass(t_idx);

        % Recompute scaled template size to know the bounding box size
        templ = templates{t_idx};
        templ_scaled = imresize(templ, scale);
        [t_h, t_w] = size(templ_scaled);

        % Clamp bounding box to image borders
        r1 = max(1, r1); % Top bounding
        c1 = max(1, c1); % Left bounding
        r2 = min(img_h, r1+t_h-1); % Bottom bounding
        c2 = min(img_w, c1+t_w-1); % Right bounding

        % Extract ROI from original RGB image
        roi =  img(r1:r2, c1:c2, :);

        % Check if this ROI has the expected color
        is_same = verifyColorByClass(roi, color_class);

        if is_same && score < 6
            verified_matches{v_idx} = [t_idx, scale, r1, c1, score];
            v_idx = v_idx + 1;
        end
    end

    %% Step 4: Draw Bounding Box and Display Result
    numMatches = size(verified_matches, 1);
    bboxes = zeros(numMatches, 4);
    
    for k = 1:numMatches
        templateIdx = verified_matches(k, 1);
        scaleFactor = verified_matches(k, 2);
           
        x = verified_matches(k, 3);   % top-left column
        y = verified_matches(k, 4);   % top-left row
    tmpl = templates{templateIdx};
    [tmplH, tmplW] = size(tmpl);
    
    boxW = tmplW * scaleFactor;
    boxH = tmplH * scaleFactor;

    bbox = [x, y, boxW, boxH];
    imgWithBox = insertShape(img, "Rectangle", bbox, "Color", "red", "LineWidth", 2);

    outPath = fullfile(resultFolder, "bbox_" + fileName);
    imwrite(imgWithBox, outPath);
end
